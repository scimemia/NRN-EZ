//Version 1.1.4
objref mloc, mtime, mweight, mwvars

mloc = newMat("./***PATH***/syn_loc.dat")
mtime = newMat("./***PATH***/syn_time.dat")
mweight = newMat("./***PATH***/syn_weight.dat")
mwvars = newMat("./***PATH***/vars_weight.dat")

nsyn=mloc.nrow

objref rsyn_//~~~STIMVAR~~~//[nsyn][mweight.ncol], nc_//~~~STIMVAR~~~//[nsyn][mweight.ncol]

objref s_//~~~STIMVAR~~~//[nsyn]


for n = 0, nsyn-1 {
    dist = mloc.x[n][1]
//~~~SOMA~~~//
    if (mloc.x[n][0] == 0) {
       soma[dist] {

           s_//~~~STIMVAR~~~//[n] = new NetStims(rel)
           s_//~~~STIMVAR~~~//[n].interval=0  //time between spikes
           s_//~~~STIMVAR~~~//[n].number = 1   ///number of spikes
           s_//~~~STIMVAR~~~//[n].start=mtime.x[n][0]   ///start of first spike
           s_//~~~STIMVAR~~~//[n].noise=0

           for k = 0, mweight.ncol-1 {
           	rsyn_//~~~STIMVAR~~~//[n][k] = new Exp2Syn(rel)
           	rsyn_//~~~STIMVAR~~~//[n][k].e = mwvars.x[k][0]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau1 = mwvars.x[k][1]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau2 = mwvars.x[k][2]
           	nc_//~~~STIMVAR~~~//[n][k] = new NetCon(s_//~~~STIMVAR~~~//[n],rsyn_//~~~STIMVAR~~~//[n][k],0,0,mweight.x[n][k])  //source, target, threshold, delay, weight
		}
	   }
   	}
//~~~SOMA~~~//
//~~~APICAL~~~//
    if (mloc.x[n][0] == 3) {
       apical[dist] {

           s_//~~~STIMVAR~~~//[n] = new NetStims(rel)
           s_//~~~STIMVAR~~~//[n].interval=0  //time between spikes
           s_//~~~STIMVAR~~~//[n].number = 1   ///number of spikes
           s_//~~~STIMVAR~~~//[n].start=mtime.x[n][0]   ///start of first spike
           s_//~~~STIMVAR~~~//[n].noise=0

           for k = 0, mweight.ncol-1 {
           	rsyn_//~~~STIMVAR~~~//[n][k] = new Exp2Syn(rel)
           	rsyn_//~~~STIMVAR~~~//[n][k].e = mwvars.x[k][0]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau1 = mwvars.x[k][1]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau2 = mwvars.x[k][2]
           	nc_//~~~STIMVAR~~~//[n][k] = new NetCon(s_//~~~STIMVAR~~~//[n],rsyn_//~~~STIMVAR~~~//[n][k],0,0,mweight.x[n][k])  //source, target, threshold, delay, weight
		}
	  
       	   }
       }
//~~~APICAL~~~//
//~~~BASAL~~~//
    if (mloc.x[n][0] == 2) {
       basal[dist] {

           s_//~~~STIMVAR~~~//[n] = new NetStims(rel)
           s_//~~~STIMVAR~~~//[n].interval=0  //time between spikes
           s_//~~~STIMVAR~~~//[n].number = 1   ///number of spikes
           s_//~~~STIMVAR~~~//[n].start=mtime.x[n][0]   ///start of first spike
           s_//~~~STIMVAR~~~//[n].noise=0

           for k = 0, mweight.ncol-1 {
           	rsyn_//~~~STIMVAR~~~//[n][k] = new Exp2Syn(rel)
           	rsyn_//~~~STIMVAR~~~//[n][k].e = mwvars.x[k][0]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau1 = mwvars.x[k][1]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau2 = mwvars.x[k][2]
           	nc_//~~~STIMVAR~~~//[n][k] = new NetCon(s_//~~~STIMVAR~~~//[n],rsyn_//~~~STIMVAR~~~//[n][k],0,0,mweight.x[n][k])  //source, target, threshold, delay, weight
		}
	   }
       }
//~~~BASAL~~~//
//~~~AXON~~~//
    if (mloc.x[n][0] == 1) {
       axon[dist] {

           s_//~~~STIMVAR~~~//[n] = new NetStims(rel)
           s_//~~~STIMVAR~~~//[n].interval=0  //time between spikes
           s_//~~~STIMVAR~~~//[n].number = 1   ///number of spikes
           s_//~~~STIMVAR~~~//[n].start=mtime.x[n][0]   ///start of first spike
           s_//~~~STIMVAR~~~//[n].noise=0

           for k = 0, mweight.ncol-1 {
           	rsyn_//~~~STIMVAR~~~//[n][k] = new Exp2Syn(rel)
           	rsyn_//~~~STIMVAR~~~//[n][k].e = mwvars.x[k][0]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau1 = mwvars.x[k][1]
           	rsyn_//~~~STIMVAR~~~//[n][k].tau2 = mwvars.x[k][2]
           	nc_//~~~STIMVAR~~~//[n][k] = new NetCon(s_//~~~STIMVAR~~~//[n],rsyn_//~~~STIMVAR~~~//[n][k],0,0,mweight.x[n][k])  //source, target, threshold, delay, weight
		}
	   }
       }
//~~~AXON~~~//
}


